---
title: "Protein Structure Analysis Workflow"
author: "Jan-Philipp Quast"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Protein Structure Analysis Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
<style>
body {
text-align: justify}
</style>

```{r, include = FALSE}
test_protti <- identical(Sys.getenv("TEST_PROTTI"), "true")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette will take you through all important tools **protti** provides for structural data analysis. These include functions that allow you to fetch information about structures both on a general and on the atom level. Additionally, distances between atoms can be extracted from structures. Lastly, B-factors* of structures can be manipulated to contain custom values, which gives you the ability to colour regions on structures as well as apply different values associated with each amino acid as a colour gradient. 

_*B-factors or temperature factors are used in structural biology to describe the atomic displacement in the structure. In low resolution structures they might correspond to the flexibility of regions, while in high resolution structures it should not be used to infer information regarding flexibility._

In structural proteomics, protein strucural changes can be determined using methods such as limited proteolysis coupled to mass spectrometry ([LiP-MS](https://www.nature.com/articles/nbt.2999)). In case of LiP-MS, structural changes can be identified with peptide or precursor* centric proteomics in the form of peptide fold changes. Relating this information to positions within the 3D space of a protein can be very helpful for inferring potential functional roles of those structural changes. If structural changes occur close to the active site of an enzyme, kinetics might be affected, if they occur at a protein-protein binding interface, the corresponding protein complex might have dissociated or associated. 

_*A peptide precursor is the actual molecular unit that was detected on the mass spectrometer. This is a peptide with one specific charge state and its modification(s)._

## Structural data

The world wide Protein Data Bank (wwPDB) manages and archives information about the 3D structure of proteins. Its information can be accessed through several sites such as the Research Collaboratory for Structural Bioinformatics ([RCSB](https://www.rcsb.org)). 

If working with structure files it is important to keep a few things in mind such that mistakes can be avoided. On thing to consider is that structure files come in two mainly used formats, namely the PDB file format (.pdb) and the mmCIF file format (.cif). The PDB file format is the legacy file format of the Protein Data Bank, which has been replaced with the newer mmCIF file format that stores data on biological macromolecules. All structures available in the Protein Data Bank, contain a mmCIF file, while not all contain a PDB file. Mainly large protein complexes only contain mmCIF files. 

The way both files store data and relate to each other can be quite complex. There are several resources explaining their [relation](https://mmcif.wwpdb.org/docs/pdb_to_pdbx_correspondences.html) and their [content](https://mmcif.wwpdb.org/docs/pubs/AUTHOR_ch4o5.pdf). The most important thing to know about these files for you as a user of **protti** is the fact that there are different naming conventions for elements of the structure. 

PDB files solely use the naming provided by the author of the structure in order to match the identification used in the publication that describes the structure. Columns containing author information start with the prefix "`auth_`". This includes the naming of chains (`asym_id`), atom IDs (`atom_id`) and residue IDs (`seq_id`). 

mmCIF files use both the naming provided by the author and a naming following the standardised conventions for mmCIF files. Columns containing standardised information start with the prefix "`label_`". 

_**Additional information:** The differences between author provided and standardised labeling may vary a lot depending on the structure and can be quite confusing. An example taken from the [documentation](https://mmcif.wwpdb.org/docs/pubs/AUTHOR_ch4o5.pdf) of mmCIF files describes the relationship between author provided and standardised residue IDs as follows. The `label_seq_id` (standardised residue ID) column is required to be a sequential list of positive integers, while the `auth_seq_id` (author residue ID) is not necessarily a number and the values do not have to be positive. The author may assign values to `auth_seq_id` in any desired way. For instance, the values may be used to relate this structure to a numbering scheme in a homologous structure, including sequence gaps or insertion codes. Alternatively, a scheme may be used for a truncated polymer that maintains the numbering scheme of the full length polymer. In all cases, the scheme used here must match the scheme used in the publication that describes the structure._

For the use of the functions in **protti** it is important to know that these two different conventions exist. **All functions usually take the author provided information as inputs.** This has the reason that even though the PDB file format is a legacy format, many people still mainly use this format. With the `find_peptide_in_structure()` function we provide a convenient way for you to find both the standardised and the author provided residue numberings for a peptide, protein region or amino acid, starting with their UniProt start and end position. 

# Getting started

Before starting the structural analysis of your data you need to load **protti** and additional packages used for the analysis. As described on the [main page](https://jpquast.github.io/protti/index.html) of **protti**, the [tidyverse](https://www.tidyverse.org) package collection works well together with the rest of the package, by design. You can load packages after you installed them with the `library()` function.

```{r load_packages, eval = test_protti, warning = FALSE, message = FALSE}
# Load packages
library(protti)
library(dplyr)
library(magrittr)
```

We will demonstrate the use of **protti**s structure analysis functions based on a data set of peptides that were significantly changing in a LiP-MS experiment and thus point towards a structural change in the protein. 

The functions used in this analysis can also be used in a different context than a structural proteomics experiment. Instead of peptides you can investigate the positioning of individual amino acids, or whole domains within a protein. 

## Loading data

For this vignette we use a subset of two proteins from separate LiP-MS experiments that contain peptides significantly changing in abundance due to a structural change. We combined these two proteins into one data set to showcase that multiple proteins and structures can be analysed at once. The data was obtained from the paper "Dynamic 3D proteomes reveal protein functional alterations at high resolution in situ" ([Cappelletti 2021](https://www.cell.com/cell/pdf/S0092-8674(20)31691-3.pdf)). Both experiments were conducted on purified E. coli proteins spiked into E. coli lysates. The first protein is phosphoglycerate kinase 1 (pgk) and it was treated with 25mM 3-phosphoglyceric acid (3PG). The second protein is phosphoenolpyruvate-protein phosphotransferase (ptsI) and it was treated with 25mM fructose 1,6-bisphosphatase (FBP). 

Based in structural changes observed in these proteins the authors conclude that FBP binds to the active site of ptsI and acts as a competitive inhibitor, which is confirmed by an activity assay. The structural change in pgk caused by 3PG is likely representative of substrate occupancy and correlates with metabolic flux changes.

The example data is included in protti and you can easily use it by calling the `data()` function. This will load the data into your R session.

```{r load_data, eval = test_protti, warning = FALSE}
utils::data("ptsi_pgk")
```

If you want to read your own data into R, we suggest using the `read_protti()` function. This function is a wrapper around the fast `fread()` function from the [`data.table`](https://rdatatable.gitlab.io/data.table/) package and the `clean_names()` function from the [`janitor`](http://sfirke.github.io/janitor/) package. This will allow you to not only load your data into R very fast, but also to clean up the column names into lower snake case. This will make it easier to remember them and to use them in your data analysis. Usually you would perform the following analysis after the analyses described in either the [vignette for single dose treatments](https://jpquast.github.io/protti/articles/data_analysis_single_dose_treatment_workflow.html) or the [vignette for dose response data](https://jpquast.github.io/protti/articles/data_analysis_dose_response_workflow.html).

```{r use_read_protti, eval=FALSE}
# Load data
your_data <- read_protti("your_differential_abundance_data.csv")
```

## Preparing data

First we need to annotate the data with information required for structural data analysis. To find peptides in a protein structure we need to know their positions in the protein first. For this we can use the protti function `find_peptide()`. This function searches for the peptide within the protein sequence, which we need to fetch from UniProt. For this we can use the protti function `fetch_uniprot()`. In addition to the protein sequence we will also need information about PDB identifiers associated with the protein, which can also be acessed via UniProt.

```{r prepare_data, eval = test_protti, warning = FALSE}
# Fetch UniProt information
uniprot_information <- fetch_uniprot(uniprot_ids = unique(ptsi_pgk$pg_protein_accessions),
                                     columns = c("sequence", "database(PDB)"))

# Add UniProt information and find peptide positions
ptsi_pgk_annotated <- ptsi_pgk %>% 
  left_join(uniprot_information, by = c("pg_protein_accessions" = "id")) %>% 
  find_peptide(protein_sequence = sequence, peptide_sequence = pep_stripped_sequence)
```










```{r find_peptide, eval = test_protti, warning = FALSE}
ptsi_pgk_peptide_structure_positions <- find_peptide_in_structure(
   peptide_data = ptsi_pgk_annotated,
   peptide = pep_stripped_sequence,
   start = start,
   end = end,
   uniprot_id = pg_protein_accessions,
   retain_columns = c(eg_precursor_id, diff, adj_pval))
```




functions:
* fetch_pdb -> potentially change column names to be closer to the official standard. Write documentation DONE
* fetch_metal_pdb -> leave function as is, check column names too. Write documentation DONE
* fetch_pdb_structure -> change column names to be closer to the official standard. Describe output columns in Value field. DONE
* potentially include: fetch_alphafold_prediction DONE
* find_peptide_in_structure -> change column names to be closer to official standard. DONE
* map_peptide_on_structure DONE
* create_structure_contact_map 
* score function DONE

```{r}
# test1 <- tibble::tibble(pep_stripped_sequence = c(1, 2, 1, 2), start = c(1, 30, 1, 80), end = c(10, 40, 10, 90), uniprot_id = c("Q6PJI9", "Q6PJI9", "P58004", "P58004"))
# test1 <- tibble::tibble(pep_stripped_sequence = c(1, 2), start = c(1, 30), end = c(10, 40), uniprot_id = c("Q6PJI9", "Q6PJI9"))
# test1 <- tibble::tibble(pep_stripped_sequence = c(1, 2, 1), start = c(1, 30, 1), end = c(10, 40, 10), uniprot_id = c("Q6PJI9", "Q6PJI9", "P58004"))
# test1 <- tibble::tibble(pep_stripped_sequence = c(1, 2), start = c(1, 80), end = c(10, 90), uniprot_id = c("P58004", "P58004"))
# pdb_data <- fetch_pdb("6N0M")
# 
# test2 <- find_peptide_in_structure(
#    peptide_data = test1,
#    peptide = pep_stripped_sequence,
#    start = start,
#    end = end,
#    uniprot_id = uniprot_id,
#    pdb_data  = pdb_data )
```

```{r}
# test2 %>% 
#   mutate(diff = 100,
#          auth_asym_id = "A") %>% 
#   map_peptides_on_structure(
#    uniprot_id = uniprot_id,
#    pdb_id = pdb_ids,
#    chain = auth_asym_id,
#    start_in_pdb = auth_seq_id_start,
#    end_in_pdb = auth_seq_id_end,
#    map_value = diff,
#    structure_file = "~/Desktop/Test/AF-Q6PJI9-F1-model_v1.pdb",
#    export_location = "~/Desktop/Test"
#  )
```

```{r}
# test3 <- test2 %>% 
#    drop_na(auth_seq_id_start) %>% 
#    mutate(id = ifelse(is.na(pdb_ids), uniprot_id, pdb_ids)) %>% 
#    create_structure_contact_map(
#    id = id,
#    chain = auth_asym_id,
#    start_in_pdb = auth_seq_id_start,
#    end_in_pdb = auth_seq_id_end
#  )
```



```{r fetch_pdb}
# pdb_information <- fetch_pdb(c("6HG1", "1E9I", "6D3Q", "4JHW"))
```

```{r}
# structure_information <- fetch_pdb_structure(pdb_ids = c("6HG1", "1E9I", "6D3Q", "4JHW"), return_data_frame = TRUE)
```


```{r metal_pdb}
# metal_pdb_info <- fetch_metal_pdb(id_type = "pdb", id_value = c("1g54"))
```
```{r}

# test <- fetch_alphafold_prediction(organism_name = "Methanocaldococcus jannaschii", return_data_frame = TRUE)


```

